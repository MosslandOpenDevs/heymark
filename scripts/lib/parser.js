"use strict";

const fs = require("fs");
const path = require("path");

const GENERATED_MARKER = "<!-- @generated by sync-rules - DO NOT EDIT -->";
const FRONTMATTER_REGEX = /^---\r?\n([\s\S]+?)\r?\n---\r?\n?([\s\S]*)$/;
const MARKDOWN_EXTENSION = ".md";
const RULE_SEPARATOR = "\n\n---\n\n";

/**
 * @param {string} rawValue
 * @returns {string | boolean}
 */
function parseMetadataValue(rawValue) {
    let value = rawValue.trim();
    if (
        (value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))
    ) {
        value = value.slice(1, -1);
    }

    if (value === "true") {
        return true;
    }
    if (value === "false") {
        return false;
    }

    return value;
}

/**
 * @param {string} metadataBlock
 * @returns {Record<string, string | boolean>}
 */
function parseMetadataBlock(metadataBlock) {
    const metadata = {};

    metadataBlock.split(/\r?\n/).forEach((line) => {
        const separatorIndex = line.indexOf(":");
        if (separatorIndex === -1) {
            return;
        }

        const key = line.slice(0, separatorIndex).trim();
        const rawValue = line.slice(separatorIndex + 1);
        metadata[key] = parseMetadataValue(rawValue);
    });

    return metadata;
}

function parseFrontmatter(content) {
    const match = content.match(FRONTMATTER_REGEX);
    if (!match) {
        return { metadata: {}, body: content.trim() };
    }

    const [, metadataBlock, body] = match;
    return {
        metadata: parseMetadataBlock(metadataBlock),
        body: body.trim(),
    };
}

function loadMarkdownFiles(rulesDir) {
    return fs
        .readdirSync(rulesDir)
        .filter((fileName) => fileName.endsWith(MARKDOWN_EXTENSION))
        .sort();
}

function createRuleFromFile(rulesDir, fileName) {
    const filePath = path.join(rulesDir, fileName);
    const raw = fs.readFileSync(filePath, "utf8");
    const { metadata, body } = parseFrontmatter(raw);
    const baseName = path.basename(fileName, MARKDOWN_EXTENSION);

    return {
        fileName,
        name: metadata.name || baseName,
        description: metadata.description || baseName,
        globs: metadata.globs || "",
        alwaysApply: metadata.alwaysApply === true,
        metadata,
        body,
    };
}

function loadRules(rulesDir) {
    if (!fs.existsSync(rulesDir)) {
        console.error(`[Error] Rules directory not found: ${rulesDir}`);
        console.error("  Ensure 'rules/' exists relative to the script location.");
        process.exit(1);
    }

    const files = loadMarkdownFiles(rulesDir);

    if (files.length === 0) {
        console.error(`[Error] No .md files found in: ${rulesDir}`);
        process.exit(1);
    }

    return files.map((fileName) => createRuleFromFile(rulesDir, fileName));
}

function mergeRuleBodies(rules) {
    return rules.map((rule) => rule.body).join(RULE_SEPARATOR);
}

function writeMergedFile(filePath, rules) {
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    const content = `${GENERATED_MARKER}\n\n${mergeRuleBodies(rules)}\n`;
    fs.writeFileSync(filePath, content, "utf8");
}

module.exports = {
    GENERATED_MARKER,
    parseFrontmatter,
    loadRules,
    mergeRuleBodies,
    writeMergedFile,
};
